        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>XmlParser class / xml_utils_prujohn Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="xml_utils_prujohn" data-type="XmlParser">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../xml_utils_prujohn.html">xml_utils_prujohn</a> &rsaquo; <a href="../xml_utils_prujohn/XmlParser.html">XmlParser</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../nominatim.dart.html">nominatim.dart</a></h2><h2><div class="icon-library"></div><a href="../xml_utils_prujohn.html">xml_utils_prujohn</a></h2><ul class="icon">
<li><a href="../xml_utils_prujohn/XML.html"><div class="icon-class"></div>XML</a></li>
<li><a href="../xml_utils_prujohn/XmlAttribute.html"><div class="icon-class"></div>XmlAttribute</a></li>
<li><a href="../xml_utils_prujohn/XmlCDATA.html"><div class="icon-class"></div>XmlCDATA</a></li>
<li><a href="../xml_utils_prujohn/XmlCollection.html"><div class="icon-class"></div>XmlCollection&lt;E&gt;</a></li>
<li><a href="../xml_utils_prujohn/XmlElement.html"><div class="icon-class"></div>XmlElement</a></li>
<li><a href="../xml_utils_prujohn/XmlNamespace.html"><div class="icon-class"></div>XmlNamespace</a></li>
<li><a href="../xml_utils_prujohn/XmlNode.html"><div class="icon-class"></div>XmlNode</a></li>
<li><a href="../xml_utils_prujohn/XmlNodeType.html"><div class="icon-class"></div>XmlNodeType</a></li>
<li><div class="icon-class"></div><strong>XmlParser</strong></li>
<li><a href="../xml_utils_prujohn/XmlProcessingInstruction.html"><div class="icon-class"></div>XmlProcessingInstruction</a></li>
<li><a href="../xml_utils_prujohn/XmlText.html"><div class="icon-class"></div>XmlText</a></li>
<li><a href="../xml_utils_prujohn/XmlToken.html"><div class="icon-class"></div>XmlToken</a></li>
<li><a href="../xml_utils_prujohn/XmlTokenizer.html"><div class="icon-class"></div>XmlTokenizer</a></li>
<li><a href="../xml_utils_prujohn/XmlException.html"><div class="icon-exception"></div>XmlException</a></li>
</ul>
</div>
<div class="content">
        <h2><strong>XmlParser</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<h2>XML Parser</h2>
<h3>When _withQuirks == true:</h3><ul><li>Allows optional attribute quotes for single string values</li></ul>
<pre class="source">
class XmlParser {
 final String _xml;
 final ListQueue&lt;XmlElement&gt; _scopes;
 final bool _withQuirks;
 XmlElement _root;

 static XmlElement _parse(String xml, [withQuirks = false])  {
   if (xml.isEmpty){
     throw const XmlException('Nothing to parse.');
   }
   XmlParser p = new XmlParser._internal(xml, withQuirks);

   final XmlTokenizer t = new XmlTokenizer(p._xml);

   p._parseElement(t);

   return p._root;
 }

 XmlParser._internal(this._xml, this._withQuirks) :
   _scopes = new ListQueue&lt;XmlElement&gt;();

 void _parseElement(XmlTokenizer t) {

   XmlToken tok = t.next();

   while(tok != null){

     switch(tok.kind){
       case XmlToken.START_COMMENT:
         _parseComment(t);
         break;
       case XmlToken.START_CDATA:
         _parseCDATA(t);
         break;
       case XmlToken.START_PI:
         _parsePI(t);
         break;
       case XmlToken.LT:
         _parseTag(t);
         break;
       case XmlToken.STRING:
         if (_scopes.isEmpty){
           throw const XmlException('Text not allowed in root level.'
             ' Use comments instead.');
         }else{
           _parseTextNode(t, tok._str);
           _parseTag(t);
         }
         break;
     }
     tok = t.next();
   }

   if (!_scopes.isEmpty){
     throw const XmlException('Unexpected end of file.  Not all tags were'
       ' closed.');
   }
 }

 _parsePI(XmlTokenizer t){

   XmlToken next = t.next();

   _assertKind(next, XmlToken.STRING);
   var data = next._str;

   next = t.next();
   _assertKind(next, XmlToken.END_PI);

   if (_scopes.isEmpty) {
       if (_root == null &amp;&amp; data != null &amp;&amp; data.startsWith("xml ")) {
         // Ignore XML declaration at the beginning, i.e &lt;?xml â€¦ ?&gt;
         return;
       } else {
           throw const XmlException('PI nodes are not supported in the top'
           ' level.');
       }
   }

   _peek().addChild(new XmlProcessingInstruction(data));
 }

 _parseCDATA(XmlTokenizer t){
   if (_scopes.isEmpty){
     throw const XmlException('CDATA nodes are not supported in the top'
       ' level.');
   }

   XmlToken next = t.next();

   _assertKind(next, XmlToken.STRING);
   var data = next._str;

   next = t.next();
   _assertKind(next, XmlToken.END_CDATA);

   _peek().addChild(new XmlCDATA(data));
 }

 //TODO create and XMLComment object instead of just ignoring?
 _parseComment(XmlTokenizer t){
   XmlToken next = t.next();

   _assertKind(next, XmlToken.STRING);

   next = t.next();
   _assertKind(next, XmlToken.END_COMMENT);
 }

 _parseTag(XmlTokenizer t){
   XmlToken next = t.next();

   if (next == null) return;

   if (next.kind == XmlToken.SLASH){
     // this is a close tag

     next = t.next();
     _assertKind(next, XmlToken.STRING);

     var name = next._str;

     next = t.next();

     if (next.kind == XmlToken.COLON){
       //process as namespace
       next = t.next();

       _assertKind(next, XmlToken.STRING, 'Namespace prefix must pair with'
       ' a tag name: (&lt;myNamespace:tagName ...)');

       name = '${name}:${next._str}';
       next = t.next();
     }


     if (_peek().name != name){
       throw new XmlException.withDebug(
       'Expected closing tag "${_peek().name}"'
       ' but found "${name}" instead.', _xml, next._location);
     }

     _assertKind(next, XmlToken.GT);

     _pop();

     return;
   }

   //otherwise this is an open tag

   _assertKind(next, XmlToken.STRING);

   //TODO check tag name for invalid chars

   var name = next._str;

   next = t.next();

   if (next.kind == XmlToken.COLON){
     //process as namespace
     next = t.next();

     _assertKind(next, XmlToken.STRING, 'Namespace prefix must pair with'
     ' a tag name: (&lt;myNamespace:tagName ...)');

     name = '${name}:${next._str}';
   }

   XmlElement newElement = new XmlElement(name);

   if (_root == null){
     //set to root and push
     _root = newElement;
     _push(_root);
   } else{
     //add child to current scope
     _peek().addChild(newElement);
     _push(newElement);
   }
   
   var peekTag = _peek();

   var ns='';
   if (peekTag.name.contains(':')){
     ns = peekTag.name.split(':')[0];
     next = t.next();
   }

   var done = false;
   while(next != null){

     switch(next.kind){
       case XmlToken.NAMESPACE:
         _parseNamespace(t);
         break;
       case XmlToken.STRING:
         _parseAttribute(t, next._str);
         break;
       case XmlToken.GT:
         _parseElement(t);
         done = true;
         break;
       case XmlToken.SLASH:
         next = t.next();
         _assertKind(next, XmlToken.GT);
         _pop();
         done = true;
         break;
       default:
         throw new XmlException.withDebug(
           'Invalid xml ${next} found at this location.',
           _xml,
           next._location);
     }
     
     if (done)
     {
       break;
     }

     next = t.next();

     if (next == null){
       throw new Exception('Unexpected end of file.');
     }
     
   }
   
   if ((ns.isNotEmpty) &amp;&amp; (!peekTag.isNamespaceInScope(ns))){
     throw new XmlException.withDebug('Namespace "${ns}" is'
     ' not declared in scope.', _xml, next._location);      
   }
   
 }

 void _parseTextNode(XmlTokenizer t, String text){

   //in text node all tokens until &lt; are joined to a single string
   StringBuffer s = new StringBuffer();

   writeStringNode(){
     var string = s.toString();
     if (!string.isEmpty) {
       _peek().addChild(new XmlText(s.toString()));
     }
   }

   s.write(text);

   XmlToken next = t.next();

   while(next != null &amp;&amp; next.kind != XmlToken.LT){
     switch(next.kind){
       case XmlToken.START_COMMENT:
         writeStringNode();
         _parseComment(t);
         s = new StringBuffer();
         break;
       case XmlToken.START_CDATA:
         writeStringNode();
         _parseCDATA(t);
         s = new StringBuffer();
         break;
       case XmlToken.START_PI:
         writeStringNode();
         _parsePI(t);
         s = new StringBuffer();
         break;
       default:
         s.write(next.toStringLiteral());
         break;
     }

     next = t.next();

     if (next == null){
       throw const XmlException('Unexpected end of file.');
     }
   }

   writeStringNode();
 }

 void _parseNamespace(XmlTokenizer t){
   XmlElement el = _peek();

   void setNamespace(String name, String uri){
     el.namespaces[name] = uri;
   }

   XmlToken next = t.next();
   _assertKind(next, XmlToken.STRING, "Must declare namespace name.");
   var name = next._str;

   next = t.next();
   _assertKind(next, XmlToken.EQ, "Must have an = after a"
     " namespace name.");

   next = t.next();

   void quotesRequired(){
     //require quotes

     _assertKind(next, XmlToken.QUOTE, "Quotes are required around"
       " attribute values.");

     StringBuffer s = new StringBuffer();

     int qkind = next.quoteKind;

     do {
       next = t.next();

       if (next == null){
         throw const XmlException('Unexpected end of file.');
       }

       if (next.kind != XmlToken.QUOTE){
         s.write(next.toStringLiteral());
       }else{
         if (next.quoteKind != qkind){
           s.write(next.toStringLiteral());
         }else{
           qkind = -1;
         }
       }

     } while (qkind != -1);


     setNamespace(name, s.toString());
   }


   if (_withQuirks){
     if (next.kind == XmlToken.STRING){
       setNamespace(name, next._str);
     }else if (next.kind == XmlToken.QUOTE){
       quotesRequired();
     }
   }else{
     quotesRequired();
   }
 }

 void _parseAttribute(XmlTokenizer t, String attributeName){
   XmlElement el = _peek();

   void setAttribute(String name, String value){
     if (name == 'xmlns'){
       // default namespace
       el.namespaces[''] = value;
     }else{
       //TODO validate well-formed attribute names
       el.attributes[name] = value;
     }
   }

   XmlToken next = t.next();

   if (next.kind == XmlToken.COLON){
     //process as namespace
     next = t.next();

     _assertKind(next, XmlToken.STRING, 'Namespace prefix must pair with'
     ' an attribute name: (myNamespace:myattribute="...")');

     var result = t.lookAheadMatch(
      [
      new XmlToken(XmlToken.NAMESPACE),
      new XmlToken.string(attributeName)
      ],
      until:
      [
       new XmlToken(XmlToken.GT)
      ],
      index: t.lastTokenIndex);

     if (!el.isNamespaceInScope(attributeName) &amp;&amp; result == false){
       print('$result $attributeName');
       throw new XmlException.withDebug('xxNamespace "$attributeName" is'
         ' not declared in scope.', _xml, next._location);
     }

     attributeName = '${attributeName}:${next._str}';
     next = t.next();
   }

   _assertKind(next, XmlToken.EQ, "Must have an = after an"
     " attribute name.");

   next = t.next();

   void quotesRequired(){
     //require quotes

     _assertKind(next, XmlToken.QUOTE, "Quotes are required around"
       " attribute values.");

     StringBuffer s = new StringBuffer();

     int qkind = next.quoteKind;

     do {
       next = t.next();

       if (next == null){
         throw const XmlException('Unexpected end of file.');
       }

       if (next.kind != XmlToken.QUOTE){
         s.write(next.toStringLiteral());
       }else{
         if (next.quoteKind != qkind){
           s.write(next.toStringLiteral());
         }else{
           qkind = -1;
         }
       }

     } while (qkind != -1);


     setAttribute(attributeName, s.toString());
   }


   if (_withQuirks){
     if (next.kind == XmlToken.STRING){
       setAttribute(attributeName, next._str);
     }else if (next.kind == XmlToken.QUOTE){
       quotesRequired();
     }
   }else{
     quotesRequired();
   }
 }


 void _push(XmlElement element){
 //  print('pushing element ${element.tagName}');
   _scopes.addFirst(element);
 }
 XmlElement _pop(){
 //  print('popping element ${_peek().tagName}');
   _scopes.removeFirst();
 }
 XmlElement _peek() =&gt; _scopes.first;

 void _assertKind(XmlToken tok, int matchID, [String info = null]){
   XmlToken match = new XmlToken(matchID);

   var msg = 'Expected ${match}, but found ${tok}. ${info == null ? "" :
     "\r$info"}';

   if (tok != null &amp;&amp; tok.kind != match.kind) {
     throw new XmlException.withDebug(msg, _xml, tok._location);
   }
 }
}
</pre>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-12-31 15:01:30.848</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
