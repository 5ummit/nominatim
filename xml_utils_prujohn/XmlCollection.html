        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>XmlCollection&lt;E&gt; class / xml_utils_prujohn Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="xml_utils_prujohn" data-type="XmlCollection&amp;lt;E&amp;gt;">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../xml_utils_prujohn.html">xml_utils_prujohn</a> &rsaquo; <a href="../xml_utils_prujohn/XmlCollection.html">XmlCollection&lt;E&gt;</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../nominatim.dart.html">nominatim.dart</a></h2><h2><div class="icon-library"></div><a href="../xml_utils_prujohn.html">xml_utils_prujohn</a></h2><ul class="icon">
<li><a href="../xml_utils_prujohn/XML.html"><div class="icon-class"></div>XML</a></li>
<li><a href="../xml_utils_prujohn/XmlAttribute.html"><div class="icon-class"></div>XmlAttribute</a></li>
<li><a href="../xml_utils_prujohn/XmlCDATA.html"><div class="icon-class"></div>XmlCDATA</a></li>
<li><div class="icon-class"></div><strong>XmlCollection&lt;E&gt;</strong></li>
<li><a href="../xml_utils_prujohn/XmlElement.html"><div class="icon-class"></div>XmlElement</a></li>
<li><a href="../xml_utils_prujohn/XmlNamespace.html"><div class="icon-class"></div>XmlNamespace</a></li>
<li><a href="../xml_utils_prujohn/XmlNode.html"><div class="icon-class"></div>XmlNode</a></li>
<li><a href="../xml_utils_prujohn/XmlNodeType.html"><div class="icon-class"></div>XmlNodeType</a></li>
<li><a href="../xml_utils_prujohn/XmlParser.html"><div class="icon-class"></div>XmlParser</a></li>
<li><a href="../xml_utils_prujohn/XmlProcessingInstruction.html"><div class="icon-class"></div>XmlProcessingInstruction</a></li>
<li><a href="../xml_utils_prujohn/XmlText.html"><div class="icon-class"></div>XmlText</a></li>
<li><a href="../xml_utils_prujohn/XmlToken.html"><div class="icon-class"></div>XmlToken</a></li>
<li><a href="../xml_utils_prujohn/XmlTokenizer.html"><div class="icon-class"></div>XmlTokenizer</a></li>
<li><a href="../xml_utils_prujohn/XmlException.html"><div class="icon-exception"></div>XmlException</a></li>
</ul>
</div>
<div class="content">
        <h2><strong>XmlCollection&lt;E extends XmlNode&gt;</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Represents a queryable collection of <a class="crossref" href="../xml_utils_prujohn/XmlNode.html">XmlNode</a> elements.</p>
<pre class="source">
class XmlCollection&lt;E extends XmlNode&gt; extends ListBase&lt;E&gt; {
 final List&lt;E&gt; _collection = new List&lt;E&gt;();

 XmlCollection._internal();

 XmlCollection._from(Iterable&lt;E&gt; iterable) {
   _collection.addAll(iterable);
 }

 /**
  * Returns the element at the given [index] in the list or throws
  * an [RangeError] if [index] is out of bounds.
  */
 E operator [](int index) =&gt; _collection[index];

 /**
  * Sets the entry at the given [index] in the list to [value].
  * Throws an [RangeError] if [index] is out of bounds.
  */
 void operator []=(int index, E value) {
   _collection[index] = value;
 }

 int get length =&gt; _collection.length;

 /**
  * Changes the length of the list. If [newLength] is greater than
  * the current [length], entries are initialized to [:null:]. Throws
  * an [UnsupportedError] if the list is not extendable.
  */
 void set length(int newLength) {
   _collection.length = newLength;
 }

 /**
  * Adds value at the end of the list, extending the length by one. Throws
  * an UnsupportedError if the list is not extendable.
  *
  * Deprecated: Use add instead.
  */
 void addLast(E value) =&gt; _collection.add(value);

 /**
  * Adds [value] at the end of the list, extending the length by
  * one. Throws an [UnsupportedError] if the list is not
  * extendable.
  */
 void add(XmlNode value) =&gt; _collection.add(value);

 /**
  * Appends all elements of the [iterable] to the end of this list.
  * Extends the length of the list by the number of elements in [iterable].
  * Throws an [UnsupportedError] if this list is not extensible.
  */
 void addAll(Iterable&lt;E&gt; iterable) =&gt; _collection.addAll(iterable);

 /**
  * Returns a new list containing the elemenst from [start] to [end].
  *
  * If [end] is omitted, the [length] of the list is used.
  *
  * It is an error if [start] or [end] are not list indices for this list,
  * or if [end] is before [start].
  */
 List&lt;E&gt; sublist(int start, [int end]) =&gt; _collection.sublist(start, end);

 /**
  * Returns a reversed fixed-length view of this [List].
  *
  * The reversed list has elements in the opposite order of this list.
  * It is backed by this list, but will stop working if this list
  * becomes shorter than its current length.
  */
 List&lt;E&gt; get reversed =&gt; _collection.reversed;

 /**
  * Sorts the list according to the order specified by the [compare] function.
 *
  * The [compare] function must act as a [Comparator].
  * The default [List] implementations use [Comparable.compare] if
  * [compare] is omitted.
  */
 void sort([int compare(E a, E b)]) {
   _collection.sort(compare);
 }

 /**
  * Returns a lazy [Iterable] where each element [:e:] of [this] is replaced
  * by the result of [:f(e):].
  *
  * This method returns a view of the mapped elements. As long as the
  * returned [Iterable] is not iterated over, the supplied function [f] will
  * not be invoked. The transformed elements will not be cached. Iterating
  * multiple times over the the returned [Iterable] will invoke the supplied
  * function [f] multiple times on the same element.
  */
 Iterable map(f(E element)) =&gt; _collection.map(f);

 /**
  * Expand each element of this [Iterable] into zero or more elements.
  *
  * The resulting Iterable will run through the elements returned
  * by [f] for each element of this, in order.
  *
  * The returned [Iterable] is lazy, and will call [f] for each element
  * of this every time it's iterated.
  */
 Iterable expand(Iterable f(E element)) =&gt; _collection.expand(f);

 /**
 * Returns an unmodifiable Map view of this.
 *
 * It has the indices of this list as keys, and the corresponding elements
 * as values.
 */
 Map&lt;int, E&gt; asMap() =&gt; _collection.asMap();

 /**
  * Returns the first index of [element] in the list.
  *
  * Searches the list from index [start] to the length of the list.
  * The first time an element [:e:] is encountered so that [:e == element:],
  * the index of [:e:] is returned.
  * Returns -1 if [element] is not found.
  */
 int indexOf(E element, [int start = 0]) =&gt;
     _collection.indexOf(element, start);

 /**
  * Returns the last index of [element] in the list.
 *
  * Searches the list backwards from index [start] (inclusive) to 0.
  * The first time an element [:e:] is encountered so that [:e == element:],
  * the index of [:e:] is returned.
  * If start is not provided, it defaults to [:this.length - 1:] .
  * Returns -1 if [element] is not found.
  */
 int lastIndexOf(E element, [int start]) =&gt;
     _collection.lastIndexOf(element, start);

 /**
  * Removes all elements in the list.
 *
  * The length of the list becomes zero.
  * Throws an [UnsupportedError], and retains all elements, if the
  * length of the list cannot be changed.
  */
 void clear() {
   _collection.clear();
 }

 /**
  * Removes the element at position[index] from the list.
 *
  * This reduces the length of the list by one and moves all later elements
  * down by one position.
  * Returns the removed element.
  * Throws an [ArgumentError] if [index] is not an [int].
  * Throws an [RangeError] if the [index] does not point inside
  * the list.
  * Throws an [UnsupportedError], and doesn't remove the element,
  * if the length of the list cannot be changed.
  */
 E removeAt(int index) =&gt; _collection.removeAt(index);

 /**
  * Pops and returns the last element of the list.
  * Throws a [UnsupportedError] if the length of the
  * list cannot be changed.
  */
 E removeLast() =&gt; _collection.removeLast();

 /**
  * Copies [length] elements of [from], starting
  * at [startFrom], into the list, starting at [start].
  * If [length] is 0, this method does not do anything.
  * Throws an [ArgumentError] if [length] is negative.
  * Throws an [RangeError] if [start] or
  * [:start + length - 1:] are out of range for [:this:], or if
  * [startFrom] or [:startFrom + length - 1:] are out of range for [from].
  */
 void setRange(int start, int length, List&lt;E&gt; from, [int startFrom]) {
   _collection.setRange(start, length, from, startFrom);
 }

 /**
  * Removes [length] elements from the list, beginning at [start].
  * Throws an [UnsupportedError] if the list is
  * not extendable.
  * If [length] is 0, this method does not do anything.
  * Throws an [ArgumentError] if [length] is negative.
  * Throws an [RangeError] if [start] or
  * [:start + length: - 1] are out of range.
  */
 void removeRange(int start, int length) {
   _collection.removeRange(start, length);
 }

 /**
  * Inserts a new range into the list, starting from [start] to
  * [:start + length - 1:]. The entries are filled with [fill].
  * Throws an [UnsupportedError] if the list is
  * not extendable.
  * If [length] is 0, this method does not do anything.
  * If [start] is the length of the list, this method inserts the
  * range at the end of the list.
  * Throws an [ArgumentError] if [length] is negative.
  * Throws an [RangeError] if [start] is negative or if
  * [start] is greater than the length of the list.
  */
 void insertRange(int start, int length, [E fill]) {
   _collection.fillRange(start, length, fill);
 }


 // From [Collection].

 /**
  * Adds an element to this collection.
  */
 //void add(E element) =&gt; _collection.add(element);

 /**
  * Adds all of [elements] to this collection.
 *
  * Equivalent to adding each element in [elements] using [add],
  * but some collections may be able to optimize it.
  */
 //void addAll(Iterable&lt;E&gt; elements) =&gt; _collection.addAll(elements);

 /**
  * Removes an instance of [element] from this collection.
 *
  * This removes only one instance of the element for collections that can
  * contain the same element more than once (e.g., [List]). Which instance
  * is removed is decided by the collection.
 *
  * Has no effect if the elements is not in this collection.
  */
 bool remove(E element) =&gt; _collection.remove(element);

 /**
  * Removes all of [elements] from this collection.
 *
  * Equivalent to calling [remove] once for each element in
  * [elements], but may be faster for some collections.
  */
 void removeAll(Iterable elements) {
   for (var element in elements) {
     _collection.remove(element);
   }
 }

 /**
  * Removes all elements of this collection that are not
  * in [elements].
 *
  * For [Set]s, this is the intersection of the two original sets.
  */
 void retainAll(Iterable elements) {
   _collection.retainWhere((e) =&gt; elements.contains(e));
 }

 // From [Iterable].

 /**
  * Returns an [Iterator] that iterates over this [Iterable] object.
  */
 Iterator&lt;E&gt; get iterator =&gt; _collection.iterator;

 /**
   * Returns a lazy [Iterable] with all elements that satisfy the
   * predicate [f].
   *
   * This method returns a view of the mapped elements. As long as the
   * returned [Iterable] is not iterated over, the supplied function [f] will
   * not be invoked. Iterating will not cache results, and thus iterating
   * multiple times over the the returned [Iterable] will invoke the supplied
   * function [f] multiple times on the same element.
   */
 Iterable&lt;E&gt; where(bool f(E element)) =&gt; _collection.where(f);

 /**
  * Check whether the collection contains an element equal to [element].
  */
 bool contains(E element) =&gt; _collection.contains(element);

 /**
  * Applies the function [f] to each element of this collection.
  */
 void forEach(void f(E element)) {
   _collection.forEach(f);
 }

 /**
  * Fold a collection to a single value by iteratively combining each element
  * of the collection with an existing value using the provided function.
  * Use [initialValue] as the initial value, and the function [combine] to
  * create a new value from the previous one and an element.
  *
  * Example of calculating the sum of a collection:
  *
  *   collection.fold(0, (prev, element) =&gt; prev + element);
  */
 dynamic fold(var initialValue,
              dynamic combine(var previousValue, E element)) =&gt;
     _collection.fold(initialValue, combine);

 /**
  * Reduces a collection to a single value by iteratively combining elements
  * of the collection using the provided function.
  *
  * Example of calculating the sum of an iterable:
  *
  *     iterable.reduce((value, element) =&gt; value + element);
  *
  */
 dynamic reduce(dynamic combine(var previousValue, E element)) =&gt;
     _collection.reduce(combine);

 /**
  * Returns true if every elements of this collection satisify the
  * predicate [f]. Returns false otherwise.
  */
 bool every(bool f(E element)) =&gt; _collection.every(f);

 /**
  * Convert each element to a [String] and concatenate the strings.
  *
  * Converts each element to a [String] by calling [Object.toString] on it.
  * Then concatenates the strings, optionally separated by the [separator]
  * string.
  */
 String join([String separator]) =&gt; _collection.join(separator);

 /**
  * Returns true if one element of this collection satisfies the
  * predicate [f]. Returns false otherwise.
  */
 bool any(bool f(E element)) =&gt; _collection.any(f);

 List&lt;E&gt; toList({growable : true}) =&gt; new List&lt;E&gt;.from(this);
 Set&lt;E&gt; toSet() =&gt; new Set&lt;E&gt;.from(this);

 /**
  * Returns true if there is no element in this collection.
  */
 bool get isEmpty =&gt; _collection.isEmpty;

 /**
  * Returns an [Iterable] with at most [n] elements.
  *
  * The returned [Iterable] may contain fewer than [n] elements, if [this]
  * contains fewer than [n] elements.
  */
 Iterable&lt;E&gt; take(int n) =&gt; _collection.take(n);

 /**
  * Returns an [Iterable] that stops once [test] is not satisfied anymore.
  *
  * The filtering happens lazily. Every new [Iterator] of the returned
  * [Iterable] will start iterating over the elements of [this].
  * When the iterator encounters an element [:e:] that does not satisfy [test],
  * it discards [:e:] and moves into the finished state. That is, it will not
  * ask or provide any more elements.
  */
 Iterable&lt;E&gt; takeWhile(bool test(E value)) =&gt; _collection.takeWhile(test);

 /**
  * Returns an [Iterable] that skips the first [n] elements.
  *
  * If [this] has fewer than [n] elements, then the resulting [Iterable] will
  * be empty.
  */
 Iterable&lt;E&gt; skip(int n) =&gt; _collection.skip(n);

 /**
  * Returns an [Iterable] that skips elements while [test] is satisfied.
  *
  * The filtering happens lazily. Every new [Iterator] of the returned
  * [Iterable] will iterate over all elements of [this].
  * As long as the iterator's elements do not satisfy [test] they are
  * discarded. Once an element satisfies the [test] the iterator stops testing
  * and uses every element unconditionally.
  */
 Iterable&lt;E&gt; skipWhile(bool test(E value)) =&gt; _collection.skipWhile(test);

 /**
  * Returns the first element.
  *
  * If [this] is empty throws a [StateError]. Otherwise this method is
  * equivalent to [:this.elementAt(0):]
  */
 E get first =&gt; _collection.first;

 /**
  * Returns the last element.
  *
  * If [this] is empty throws a [StateError].
  */
 E get last =&gt; _collection.last;

 /**
  * Returns the single element in [this].
  *
  * If [this] is empty or has more than one element throws a [StateError].
  */
 E get single =&gt; _collection.single;

 /**
  * Returns the [index]th element.
  *
  * If [this] [Iterable] has fewer than [index] elements throws a
  * [RangeError].
  *
  * Note: if [this] does not have a deterministic iteration order then the
  * function may simply return any element without any iteration if there are
  * at least [index] elements in [this].
  */
 E elementAt(int index) =&gt; _collection.elementAt(index);

 /**
  * Returns the first element that satisfies the given predicate [f].
  *
  * If none matches, the result of invoking the [orElse] function is
  * returned. By default, when [orElse] is `null`, a [StateError] is
  * thrown.
  */
 E firstWhere(bool test(E value), { E orElse() }) =&gt;
     _collection.firstWhere(test, orElse:orElse);

 /**
  * Returns the last element that satisfies the given predicate [f].
  *
  * If none matches, the result of invoking the [orElse] function is
  * returned. By default, when [orElse] is [:null:], a [StateError] is
  * thrown.
  */
 E lastWhere(bool test(E value), {E orElse()}) =&gt;
     _collection.lastWhere(test, orElse:orElse);

 /**
  * Returns the single element that satisfies [f]. If no or more than one
  * element match then a [StateError] is thrown.
  */
 E singleWhere(bool test(E value)) =&gt; _collection.singleWhere(test);

 /**
  * Removes all elements of this collection that satisfy [test].
  *
  * An elements [:e:] satisfies [test] if [:test(e):] is true.
  */
 void removeWhere(bool test(E element)) =&gt; _collection.removeWhere(test);

 /**
  * Removes all elements of this collection that fail to satisfy [test].
  *
  * An elements [:e:] satisfies [test] if [:test(e):] is true.
  */
 void retainWhere(bool test(E element)) =&gt; _collection.retainWhere(test);

 /**
  * Inserts the element at position [index] in the list.
  *
  * This increases the length of the list by one and shifts all later elements
  * towards the end of the list.
  *
  * It is an error if the [index] does not point inside the list or at the
  * position after the last element.
  */
 void insert(int index, E element) =&gt; _collection.insert(index, element);



//  /**
//   * Check whether the collection contains an element equal to [element].
//   */
//  bool contains(E element) =&gt; _collection.contains(element);
//
//  /**
//   * Returns the last element of the [XmlCollection], or throws an out of bounds
//   * exception if the [XmlCollection] is empty.
//   */
//  E get last =&gt; _collection.last;
//
//  /**
//   * Returns the first index of [element] in this [XmlCollection].
//   * Searches this [XmlCollection] from index [start] to the length of the
//   * [XmlCollection]. Returns -1 if [element] is not found.
//   */
//  indexOf(E element) =&gt; _collection.indexOf(element);
//
//
//  /**
//   * Reduce a collection to a single value by iteratively combining each element
//   * of the collection with an existing value using the provided function.
//   * Use [initialValue] as the initial value, and the function [combine] to
//   * create a new value from the previous one and an element.
//   *
//   * Example of calculating the sum of a collection:
//   *
//   *   collection.reduce(0, (prev, element) =&gt; prev + element);
//   */
//  dynamic reduce(dynamic initialValue,
//                 dynamic combine(dynamic previousValue, E element))
//  =&gt; _collection.reduce(initialValue, combine);
//
//
//
//  /**
//   * Returns the element at the given [index] in the [XmlCollection] or throws
//   * an [IndexOutOfRangeException] if [index] is out of bounds.
//   */
//  E operator [](int index) =&gt; _collection[index];
//
//  void _add(E element) =&gt; _collection.add(element);
//
//  void _removeRange(int start, int length) =&gt;
//      _collection.removeRange(start, length);
//
//  /**
//   * Applies the function [f] to each element of this collection.
//   */
//  void forEach(void f(E element)) =&gt; _collection.forEach(f);
//
//  /**
//   * Returns a new [XmlCollection] with the elements [: f(e) :]
//   * for each element [e] of this collection.
//   *
//   * Note on typing: the return type of f() could be an arbitrary
//   * type and consequently the returned collection's
//   * typeis Collection.
//   */
//  XmlCollection map(f(E element)) =&gt;
//      new XmlCollection._from(_collection.mappedBy(f).toList());
//
//  /**
//   * Returns a new [XmlCollection] with the elements of this collection
//   * that satisfy the predicate [f].
//   *
//   * An element satisfies the predicate [f] if [:f(element):]
//   * returns true.
//   */
//  XmlCollection&lt;E&gt; filter(bool f(E element))
//  =&gt; new XmlCollection._from(_collection.where(f).toList());
//

 XmlCollection&lt;XmlElement&gt; allElements() =&gt;
     new XmlCollection._from(_collection.where((n) =&gt; n is XmlElement));

 /**
 * Returns the first node in the tree that matches the given [queryOn]
 * parameter.
 *
 * ## Usage ##
 * * query('tagName') // returns first occurance matching tag name.
 * * query(XmlNodeType.CDATA) // returns first occurance of element matching
 * the given node type (CDATA node in this example).
 * * query({'attributeName':'attributeValue'}) // returns the first occurance
 * of any [XmlElement] where the given attributes/values are found.
 */
 XmlCollection&lt;E&gt; query(queryOn){
   XmlCollection&lt;E&gt; list = new XmlCollection._internal();

   if (queryOn is String){
     for (final node in this.allElements()){
       _queryNameInternal(queryOn, list, node);
       if (!list.isEmpty) break;
     }
   }else if (queryOn is XmlNodeType){
     for (final node in this){
       _queryNodeTypeInternal(queryOn, list, node);
       if (!list.isEmpty) break;
     }
   }else if (queryOn is Map){
     for (final node in this.allElements()){
       _queryAttributeInternal(queryOn, list, node);
       if (!list.isEmpty) break;
     }
   }

   return list;
 }


 void _queryAttributeInternal(Map aMap,
                              XmlCollection&lt;E&gt; list,
                              XmlElement n){
   bool checkAttribs(){
     var succeed = true;

     //TODO needs better implementation to
     //break out on first false
     aMap.forEach((k, v){
       if (succeed &amp;&amp; n.attributes.containsKey(k)) {
         if (n.attributes[k] != v) succeed = false;
       }else{
         succeed = false;
       }
     });

     return succeed;
   }

   if (checkAttribs()){
     list.add(n);
     return;
   }else{
     if (n.hasChildren){
       n.children
       .allElements()
       .forEach((el){
         if (!list.isEmpty) return;
         (el as XmlElement)._queryAttributeInternal(aMap, list);
       });
     }
   }
 }

 void _queryNodeTypeInternal(XmlNodeType nodeType,
                             XmlCollection&lt;E&gt; list,
                             XmlNode node){
   if (node.type == nodeType){
     list.add(node);
     return;
   }else{
     if ((node as XmlElement).hasChildren){
       (node as XmlElement).children
         .forEach((el){
           if (!list.isEmpty) return;
           if (el is XmlElement){
             el._queryNodeTypeInternal(nodeType, list);
           }else{
             if (el.type == nodeType){
               list.add(el);
               return;
             }
           }
         });
     }
   }
 }

 void _queryNameInternal(String tagName, XmlCollection&lt;E&gt; list,
                         XmlElement element){

   if (element.name == tagName){
     list.add(element);
     return;
   }else{
     if (element.hasChildren){
       element.children
         .allElements()
         .forEach((el){
           if (!list.isEmpty) return;
           el._queryNameInternal(tagName, list);
         });
     }
   }
 }

 /**
 * Returns a list of nodes in the tree that match the given [queryOn]
 * parameter.
 *
 * ## Usage ##
 * * query('tagName') = returns first occurance matching tag name.
 * * query(XmlNodeType.CDATA) // returns first occurance of element matching
 * the given node type (CDATA node in this example).
 */
 XmlCollection&lt;E&gt; queryAll(queryOn){
   var list = new XmlCollection&lt;E&gt;._internal();

   if (queryOn is String){
     for (final node in this.allElements()){
       _queryAllNamesInternal(queryOn, list, node);
     }
   }else if (queryOn is XmlNodeType){
     for (final node in this){
       _queryAllNodeTypesInternal(queryOn, list, node);
     }
   }else if (queryOn is Map){
     for (final node in this.allElements()){
       _queryAllAttributesInternal(queryOn, list, node);
     }
   }

   return list;
 }

 void _queryAllAttributesInternal(Map aMap,
                                  XmlCollection&lt;E&gt; list,
                                  XmlElement element){
   bool checkAttribs(){
     var succeed = true;

     //TODO needs better implementation to
     //break out on first false
     aMap.forEach((k, v){
       if (succeed &amp;&amp; element.attributes.containsKey(k)) {
         if (element.attributes[k] != v) succeed = false;
       }else{
         succeed = false;
       }
     });

     return succeed;
   }

   if (checkAttribs()){
     list.add(element);
   }else{
     if (element.hasChildren){
       element.children
       .allElements()
       .forEach((el){
         el._queryAttributeInternal(aMap, list);
       });
     }
   }
 }

 void _queryAllNodeTypesInternal(XmlNodeType nodeType,
                                 XmlCollection&lt;E&gt; list,
                                 XmlNode node){
   if (node.type == nodeType){
     list.add(node);
   }else{
     if ((node as XmlElement).hasChildren){
       (node as XmlElement).children
         .forEach((el){
           if (el is XmlElement){
             el._queryAllNodeTypesInternal(nodeType, list);
           }else{
             if (el.type == nodeType){
               list.add(el);
             }
           }
         });
     }
   }
 }

 void _queryAllNamesInternal(String tagName,
                        XmlCollection&lt;E&gt; list,
                        XmlElement element){
   if (element.name == tagName){
     list.add(element);
   }

   if (element.hasChildren){
     element.children
     .where((el) =&gt; el is XmlElement)
     .forEach((el){
       el._queryAllNamesInternal(tagName, list);
     });
   }
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../dart_collection/ListBase.html">ListBase&lt;E&gt;</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>XmlCollection&lt;E&gt;</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="first">
<button class="show-code">Code</button>
final <a href="../xml_utils_prujohn/XmlCollection.html">E</a>         <strong>first</strong> <a class="anchor-link"
            href="#first"
            title="Permalink to XmlCollection&lt;E&gt;.first">#</a>
        </h4>
        <div class="doc">
<p>Returns the first element.</p>
<p>If <code>this</code> is empty throws a <a class="crossref" href="../dart_core/StateError.html">StateError</a>. Otherwise this method is
equivalent to <code>this.elementAt(0)</code></p>
<pre class="source">
E get first =&gt; _collection.first;
</pre>
</div>
</div>
<div class="field"><h4 id="isEmpty">
<button class="show-code">Code</button>
final bool         <strong>isEmpty</strong> <a class="anchor-link"
            href="#isEmpty"
            title="Permalink to XmlCollection&lt;E&gt;.isEmpty">#</a>
        </h4>
        <div class="doc">
<p>Returns true if there is no element in this collection.</p>
<pre class="source">
bool get isEmpty =&gt; _collection.isEmpty;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="isNotEmpty">
<button class="show-code">Code</button>
final bool         <strong>isNotEmpty</strong> <a class="anchor-link"
            href="#isNotEmpty"
            title="Permalink to XmlCollection&lt;E&gt;.isNotEmpty">#</a>
        </h4>
        <div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Returns true if there is at least one element in this collection.</p>
<div class="docs-inherited-from">docs inherited from Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
bool get isNotEmpty =&gt; !isEmpty;
</pre>
</div>
</div>
<div class="field"><h4 id="iterator">
<button class="show-code">Code</button>
final Iterator&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt;         <strong>iterator</strong> <a class="anchor-link"
            href="#iterator"
            title="Permalink to XmlCollection&lt;E&gt;.iterator">#</a>
        </h4>
        <div class="doc">
<p>Returns an <a class="crossref" href="../dart_core/Iterator.html">Iterator</a> that iterates over this <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> object.</p>
<pre class="source">
Iterator&lt;E&gt; get iterator =&gt; _collection.iterator;
</pre>
</div>
</div>
<div class="field"><h4 id="last">
<button class="show-code">Code</button>
final <a href="../xml_utils_prujohn/XmlCollection.html">E</a>         <strong>last</strong> <a class="anchor-link"
            href="#last"
            title="Permalink to XmlCollection&lt;E&gt;.last">#</a>
        </h4>
        <div class="doc">
<p>Returns the last element.</p>
<p>If <code>this</code> is empty throws a <a class="crossref" href="../dart_core/StateError.html">StateError</a>.</p>
<pre class="source">
E get last =&gt; _collection.last;
</pre>
</div>
</div>
<div class="method"><h4 id="length">
<button class="show-code">Code</button>
int <strong>get length</strong> <a class="anchor-link" href="#length"
              title="Permalink to XmlCollection&lt;E&gt;.get length">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns the number of objects in this list.</p>
<p>The valid indices for a list are <code>0</code> through <code>length - 1</code>.</p>
<div class="docs-inherited-from">docs inherited from List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
int get length =&gt; _collection.length;
</pre>
</div>
</div>
<div class="method"><h4 id="length=">
<button class="show-code">Code</button>
void <strong>set length</strong>(int newLength) <a class="anchor-link" href="#length="
              title="Permalink to XmlCollection&lt;E&gt;.set length">#</a></h4>
<div class="doc">
<p>Changes the length of the list. If 
<span class="param">newLength</span> is greater than
the current <a class="crossref" href="../xml_utils_prujohn/XmlCollection.html#length">length</a>, entries are initialized to <code>null</code>. Throws
an <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a> if the list is not extendable.</p>
<pre class="source">
void set length(int newLength) {
 _collection.length = newLength;
}
</pre>
</div>
</div>
<div class="field"><h4 id="reversed">
<button class="show-code">Code</button>
final List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt;         <strong>reversed</strong> <a class="anchor-link"
            href="#reversed"
            title="Permalink to XmlCollection&lt;E&gt;.reversed">#</a>
        </h4>
        <div class="doc">
<p>Returns a reversed fixed-length view of this <a class="crossref" href="../dart_core/List.html">List</a>.</p>
<p>The reversed list has elements in the opposite order of this list.
It is backed by this list, but will stop working if this list
becomes shorter than its current length.</p>
<pre class="source">
List&lt;E&gt; get reversed =&gt; _collection.reversed;
</pre>
</div>
</div>
<div class="field"><h4 id="single">
<button class="show-code">Code</button>
final <a href="../xml_utils_prujohn/XmlCollection.html">E</a>         <strong>single</strong> <a class="anchor-link"
            href="#single"
            title="Permalink to XmlCollection&lt;E&gt;.single">#</a>
        </h4>
        <div class="doc">
<p>Returns the single element in <code>this</code>.</p>
<p>If <code>this</code> is empty or has more than one element throws a <a class="crossref" href="../dart_core/StateError.html">StateError</a>.</p>
<pre class="source">
E get single =&gt; _collection.single;
</pre>
</div>
</div>
</div>
<div>
<h3>Operators</h3>
<div class="method"><h4 id="[]">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">E</a> <strong>operator []</strong>(int index) <a class="anchor-link" href="#[]"
              title="Permalink to XmlCollection&lt;E&gt;.operator []">#</a></h4>
<div class="doc">
<p>Returns the element at the given 
<span class="param">index</span> in the list or throws
an <a class="crossref" href="../dart_core/RangeError.html">RangeError</a> if 
<span class="param">index</span> is out of bounds.</p>
<pre class="source">
E operator [](int index) =&gt; _collection[index];
</pre>
</div>
</div>
<div class="method"><h4 id="[]=">
<button class="show-code">Code</button>
void <strong>operator []=</strong>(int index, <a href="../xml_utils_prujohn/XmlCollection.html">E</a> value) <a class="anchor-link" href="#[]="
              title="Permalink to XmlCollection&lt;E&gt;.operator []=">#</a></h4>
<div class="doc">
<p>Sets the entry at the given 
<span class="param">index</span> in the list to 
<span class="param">value</span>.
Throws an <a class="crossref" href="../dart_core/RangeError.html">RangeError</a> if 
<span class="param">index</span> is out of bounds.</p>
<pre class="source">
void operator []=(int index, E value) {
 _collection[index] = value;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="add">
<button class="show-code">Code</button>
void <strong>add</strong>(<a href="../xml_utils_prujohn/XmlNode.html">XmlNode</a> value) <a class="anchor-link" href="#add"
              title="Permalink to XmlCollection&lt;E&gt;.add">#</a></h4>
<div class="doc">
<p>Adds 
<span class="param">value</span> at the end of the list, extending the length by
one. Throws an <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a> if the list is not
extendable.</p>
<pre class="source">
void add(XmlNode value) =&gt; _collection.add(value);
</pre>
</div>
</div>
<div class="method"><h4 id="addAll">
<button class="show-code">Code</button>
void <strong>addAll</strong>(Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; iterable) <a class="anchor-link" href="#addAll"
              title="Permalink to XmlCollection&lt;E&gt;.addAll">#</a></h4>
<div class="doc">
<p>Appends all elements of the 
<span class="param">iterable</span> to the end of this list.
Extends the length of the list by the number of elements in 
<span class="param">iterable</span>.
Throws an <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a> if this list is not extensible.</p>
<pre class="source">
void addAll(Iterable&lt;E&gt; iterable) =&gt; _collection.addAll(iterable);
</pre>
</div>
</div>
<div class="method"><h4 id="addLast">
<button class="show-code">Code</button>
void <strong>addLast</strong>(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> value) <a class="anchor-link" href="#addLast"
              title="Permalink to XmlCollection&lt;E&gt;.addLast">#</a></h4>
<div class="doc">
<p>Adds value at the end of the list, extending the length by one. Throws
an UnsupportedError if the list is not extendable.</p>
<p>Deprecated: Use add instead.</p>
<pre class="source">
void addLast(E value) =&gt; _collection.add(value);
</pre>
</div>
</div>
<div class="method"><h4 id="allElements">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">XmlCollection</a>&lt;<a href="../xml_utils_prujohn/XmlElement.html">XmlElement</a>&gt; <strong>allElements</strong>() <a class="anchor-link" href="#allElements"
              title="Permalink to XmlCollection&lt;E&gt;.allElements">#</a></h4>
<div class="doc">
<pre class="source">
XmlCollection&lt;XmlElement&gt; allElements() =&gt;
   new XmlCollection._from(_collection.where((n) =&gt; n is XmlElement));
</pre>
</div>
</div>
<div class="method"><h4 id="any">
<button class="show-code">Code</button>
bool <strong>any</strong>(bool f(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#any"
              title="Permalink to XmlCollection&lt;E&gt;.any">#</a></h4>
<div class="doc">
<p>Returns true if one element of this collection satisfies the
predicate 
<span class="param">f</span>. Returns false otherwise.</p>
<pre class="source">
bool any(bool f(E element)) =&gt; _collection.any(f);
</pre>
</div>
</div>
<div class="method"><h4 id="asMap">
<button class="show-code">Code</button>
Map&lt;int, <a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>asMap</strong>() <a class="anchor-link" href="#asMap"
              title="Permalink to XmlCollection&lt;E&gt;.asMap">#</a></h4>
<div class="doc">
<p>Returns an unmodifiable Map view of this.</p>
<p>It has the indices of this list as keys, and the corresponding elements
as values.</p>
<pre class="source">
Map&lt;int, E&gt; asMap() =&gt; _collection.asMap();
</pre>
</div>
</div>
<div class="method"><h4 id="clear">
<button class="show-code">Code</button>
void <strong>clear</strong>() <a class="anchor-link" href="#clear"
              title="Permalink to XmlCollection&lt;E&gt;.clear">#</a></h4>
<div class="doc">
<p>Removes all elements in the list.</p>
<p>The length of the list becomes zero.
Throws an <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a>, and retains all elements, if the
length of the list cannot be changed.</p>
<pre class="source">
void clear() {
 _collection.clear();
}
</pre>
</div>
</div>
<div class="method"><h4 id="contains">
<button class="show-code">Code</button>
bool <strong>contains</strong>(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element) <a class="anchor-link" href="#contains"
              title="Permalink to XmlCollection&lt;E&gt;.contains">#</a></h4>
<div class="doc">
<p>Check whether the collection contains an element equal to 
<span class="param">element</span>.</p>
<pre class="source">
bool contains(E element) =&gt; _collection.contains(element);
</pre>
</div>
</div>
<div class="method"><h4 id="elementAt">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">E</a> <strong>elementAt</strong>(int index) <a class="anchor-link" href="#elementAt"
              title="Permalink to XmlCollection&lt;E&gt;.elementAt">#</a></h4>
<div class="doc">
<p>Returns the 
<span class="param">index</span>th element.</p>
<p>If [this] [Iterable] has fewer than 
<span class="param">index</span> elements throws a
<a class="crossref" href="../dart_core/RangeError.html">RangeError</a>.</p>
<p>Note: if <code>this</code> does not have a deterministic iteration order then the
function may simply return any element without any iteration if there are
at least 
<span class="param">index</span> elements in <code>this</code>.</p>
<pre class="source">
E elementAt(int index) =&gt; _collection.elementAt(index);
</pre>
</div>
</div>
<div class="method"><h4 id="every">
<button class="show-code">Code</button>
bool <strong>every</strong>(bool f(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#every"
              title="Permalink to XmlCollection&lt;E&gt;.every">#</a></h4>
<div class="doc">
<p>Returns true if every elements of this collection satisify the
predicate 
<span class="param">f</span>. Returns false otherwise.</p>
<pre class="source">
bool every(bool f(E element)) =&gt; _collection.every(f);
</pre>
</div>
</div>
<div class="method"><h4 id="expand">
<button class="show-code">Code</button>
Iterable <strong>expand</strong>(Iterable f(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#expand"
              title="Permalink to XmlCollection&lt;E&gt;.expand">#</a></h4>
<div class="doc">
<p>Expand each element of this <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> into zero or more elements.</p>
<p>The resulting Iterable will run through the elements returned
by 
<span class="param">f</span> for each element of this, in order.</p>
<p>The returned <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> is lazy, and will call 
<span class="param">f</span> for each element
of this every time it's iterated.</p>
<pre class="source">
Iterable expand(Iterable f(E element)) =&gt; _collection.expand(f);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="fillRange">
<button class="show-code">Code</button>
void <strong>fillRange</strong>(int start, int end, [<a href="../xml_utils_prujohn/XmlCollection.html">E</a> fill]) <a class="anchor-link" href="#fillRange"
              title="Permalink to XmlCollection&lt;E&gt;.fillRange">#</a></h4>
<div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Sets the objects in the range 
<span class="param">start</span> inclusive to 
<span class="param">end</span> exclusive
to the given <code>fillValue</code>.</p>
<p>An error occurs if 
<span class="param">start</span>..
<span class="param">end</span> is not a valid range for <code>this</code>.</p>
<div class="docs-inherited-from">docs inherited from List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
void fillRange(int start, int end, [E fill]) {
 _rangeCheck(start, end);
 for (int i = start; i &lt; end; i++) {
   this[i] = fill;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="firstWhere">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">E</a> <strong>firstWhere</strong>(bool test(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> value), {<a href="../xml_utils_prujohn/XmlCollection.html">E</a> orElse()}) <a class="anchor-link" href="#firstWhere"
              title="Permalink to XmlCollection&lt;E&gt;.firstWhere">#</a></h4>
<div class="doc">
<p>Returns the first element that satisfies the given predicate <code>f</code>.</p>
<p>If none matches, the result of invoking the 
<span class="param">orElse</span> function is
returned. By default, when 
<span class="param">orElse</span> is <code>null</code>, a <a class="crossref" href="../dart_core/StateError.html">StateError</a> is
thrown.</p>
<pre class="source">
E firstWhere(bool test(E value), { E orElse() }) =&gt;
   _collection.firstWhere(test, orElse:orElse);
</pre>
</div>
</div>
<div class="method"><h4 id="fold">
<button class="show-code">Code</button>
dynamic <strong>fold</strong>(initialValue, combine(previousValue, <a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#fold"
              title="Permalink to XmlCollection&lt;E&gt;.fold">#</a></h4>
<div class="doc">
<p>Fold a collection to a single value by iteratively combining each element
of the collection with an existing value using the provided function.
Use 
<span class="param">initialValue</span> as the initial value, and the function 
<span class="param">combine</span> to
create a new value from the previous one and an element.</p>
<p>Example of calculating the sum of a collection:</p>
<p>  collection.fold(0, (prev, element) => prev + element);</p>
<pre class="source">
dynamic fold(var initialValue,
            dynamic combine(var previousValue, E element)) =&gt;
   _collection.fold(initialValue, combine);
</pre>
</div>
</div>
<div class="method"><h4 id="forEach">
<button class="show-code">Code</button>
void <strong>forEach</strong>(void f(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#forEach"
              title="Permalink to XmlCollection&lt;E&gt;.forEach">#</a></h4>
<div class="doc">
<p>Applies the function 
<span class="param">f</span> to each element of this collection.</p>
<pre class="source">
void forEach(void f(E element)) {
 _collection.forEach(f);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getRange">
<button class="show-code">Code</button>
Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>getRange</strong>(int start, int end) <a class="anchor-link" href="#getRange"
              title="Permalink to XmlCollection&lt;E&gt;.getRange">#</a></h4>
<div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Returns an <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> that iterates over the objects in the range

<span class="param">start</span> inclusive to 
<span class="param">end</span> exclusive.</p>
<p>An error occurs if 
<span class="param">end</span> is before 
<span class="param">start</span>.</p>
<p>An error occurs if the 
<span class="param">start</span> and 
<span class="param">end</span> are not valid ranges at the time
of the call to this method. The returned <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> behaves like
<code>skip(start).take(end - start)</code>. That is, it does not throw exceptions
if <code>this</code> changes size.</p>
<pre><code>List&lt;String&gt; colors = ['red', 'green', 'blue', 'orange', 'pink'];
Iterable&lt;String&gt; range = colors.getRange(1, 4);
range.join(', ');  // 'green, blue, orange'
colors.length = 3;
range.join(', ');  // 'green, blue'
</code></pre>
<div class="docs-inherited-from">docs inherited from List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
Iterable&lt;E&gt; getRange(int start, int end) {
 _rangeCheck(start, end);
 return new SubListIterable(this, start, end);
}
</pre>
</div>
</div>
<div class="method"><h4 id="indexOf">
<button class="show-code">Code</button>
int <strong>indexOf</strong>(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element, [int start = 0]) <a class="anchor-link" href="#indexOf"
              title="Permalink to XmlCollection&lt;E&gt;.indexOf">#</a></h4>
<div class="doc">
<p>Returns the first index of 
<span class="param">element</span> in the list.</p>
<p>Searches the list from index 
<span class="param">start</span> to the length of the list.
The first time an element <code>e</code> is encountered so that <code>e == element</code>,
the index of <code>e</code> is returned.
Returns -1 if 
<span class="param">element</span> is not found.</p>
<pre class="source">
int indexOf(E element, [int start = 0]) =&gt;
   _collection.indexOf(element, start);
</pre>
</div>
</div>
<div class="method"><h4 id="insert">
<button class="show-code">Code</button>
void <strong>insert</strong>(int index, <a href="../xml_utils_prujohn/XmlCollection.html">E</a> element) <a class="anchor-link" href="#insert"
              title="Permalink to XmlCollection&lt;E&gt;.insert">#</a></h4>
<div class="doc">
<p>Inserts the element at position 
<span class="param">index</span> in the list.</p>
<p>This increases the length of the list by one and shifts all later elements
towards the end of the list.</p>
<p>It is an error if the 
<span class="param">index</span> does not point inside the list or at the
position after the last element.</p>
<pre class="source">
void insert(int index, E element) =&gt; _collection.insert(index, element);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="insertAll">
<button class="show-code">Code</button>
void <strong>insertAll</strong>(int index, Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; iterable) <a class="anchor-link" href="#insertAll"
              title="Permalink to XmlCollection&lt;E&gt;.insertAll">#</a></h4>
<div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Inserts all objects of 
<span class="param">iterable</span> at position 
<span class="param">index</span> in this list.</p>
<p>This increases the length of the list by the length of 
<span class="param">iterable</span> and
shifts all later objects towards the end of the list.</p>
<p>An error occurs if the 
<span class="param">index</span> is less than 0 or greater than length.
An <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a> occurs if the list is fixed-length.</p>
<div class="docs-inherited-from">docs inherited from List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
void insertAll(int index, Iterable&lt;E&gt; iterable) {
 if (index &lt; 0 || index &gt; length) {
   throw new RangeError.range(index, 0, length);
 }
 if (iterable is EfficientLength) {
   iterable = iterable.toList();
 }
 int insertionLength = iterable.length;
 // There might be errors after the length change, in which case the list
 // will end up being modified but the operation not complete. Unless we
 // always go through a "toList" we can't really avoid that.
 this.length += insertionLength;
 setRange(index + insertionLength, this.length, this, index);
 setAll(index, iterable);
}
</pre>
</div>
</div>
<div class="method"><h4 id="insertRange">
<button class="show-code">Code</button>
void <strong>insertRange</strong>(int start, int length, [<a href="../xml_utils_prujohn/XmlCollection.html">E</a> fill]) <a class="anchor-link" href="#insertRange"
              title="Permalink to XmlCollection&lt;E&gt;.insertRange">#</a></h4>
<div class="doc">
<p>Inserts a new range into the list, starting from 
<span class="param">start</span> to
<code>start + length - 1</code>. The entries are filled with 
<span class="param">fill</span>.
Throws an <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a> if the list is
not extendable.
If 
<span class="param">length</span> is 0, this method does not do anything.
If 
<span class="param">start</span> is the length of the list, this method inserts the
range at the end of the list.
Throws an <a class="crossref" href="../dart_core/ArgumentError.html">ArgumentError</a> if 
<span class="param">length</span> is negative.
Throws an <a class="crossref" href="../dart_core/RangeError.html">RangeError</a> if 
<span class="param">start</span> is negative or if

<span class="param">start</span> is greater than the length of the list.</p>
<pre class="source">
void insertRange(int start, int length, [E fill]) {
 _collection.fillRange(start, length, fill);
}
</pre>
</div>
</div>
<div class="method"><h4 id="join">
<button class="show-code">Code</button>
String <strong>join</strong>([String separator]) <a class="anchor-link" href="#join"
              title="Permalink to XmlCollection&lt;E&gt;.join">#</a></h4>
<div class="doc">
<p>Convert each element to a <a class="crossref" href="../dart_core/String.html">String</a> and concatenate the strings.</p>
<p>Converts each element to a <a class="crossref" href="../dart_core/String.html">String</a> by calling <a class="crossref" href="../dart_core/Object.html#toString">Object.toString</a> on it.
Then concatenates the strings, optionally separated by the 
<span class="param">separator</span>
string.</p>
<pre class="source">
String join([String separator]) =&gt; _collection.join(separator);
</pre>
</div>
</div>
<div class="method"><h4 id="lastIndexOf">
<button class="show-code">Code</button>
int <strong>lastIndexOf</strong>(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element, [int start]) <a class="anchor-link" href="#lastIndexOf"
              title="Permalink to XmlCollection&lt;E&gt;.lastIndexOf">#</a></h4>
<div class="doc">
<p>Returns the last index of 
<span class="param">element</span> in the list.</p>
<p>Searches the list backwards from index <a href="inclusive">start</a> to 0.
The first time an element <code>e</code> is encountered so that <code>e == element</code>,
the index of <code>e</code> is returned.
If start is not provided, it defaults to <code>this.length - 1</code> .
Returns -1 if 
<span class="param">element</span> is not found.</p>
<pre class="source">
int lastIndexOf(E element, [int start]) =&gt;
   _collection.lastIndexOf(element, start);
</pre>
</div>
</div>
<div class="method"><h4 id="lastWhere">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">E</a> <strong>lastWhere</strong>(bool test(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> value), {<a href="../xml_utils_prujohn/XmlCollection.html">E</a> orElse()}) <a class="anchor-link" href="#lastWhere"
              title="Permalink to XmlCollection&lt;E&gt;.lastWhere">#</a></h4>
<div class="doc">
<p>Returns the last element that satisfies the given predicate <code>f</code>.</p>
<p>If none matches, the result of invoking the 
<span class="param">orElse</span> function is
returned. By default, when 
<span class="param">orElse</span> is <code>null</code>, a <a class="crossref" href="../dart_core/StateError.html">StateError</a> is
thrown.</p>
<pre class="source">
E lastWhere(bool test(E value), {E orElse()}) =&gt;
   _collection.lastWhere(test, orElse:orElse);
</pre>
</div>
</div>
<div class="method"><h4 id="map">
<button class="show-code">Code</button>
Iterable <strong>map</strong>(f(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#map"
              title="Permalink to XmlCollection&lt;E&gt;.map">#</a></h4>
<div class="doc">
<p>Returns a lazy <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> where each element <code>e</code> of <code>this</code> is replaced
by the result of <code>f(e)</code>.</p>
<p>This method returns a view of the mapped elements. As long as the
returned <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> is not iterated over, the supplied function 
<span class="param">f</span> will
not be invoked. The transformed elements will not be cached. Iterating
multiple times over the the returned <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> will invoke the supplied
function 
<span class="param">f</span> multiple times on the same element.</p>
<pre class="source">
Iterable map(f(E element)) =&gt; _collection.map(f);
</pre>
</div>
</div>
<div class="method"><h4 id="query">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">XmlCollection</a>&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>query</strong>(queryOn) <a class="anchor-link" href="#query"
              title="Permalink to XmlCollection&lt;E&gt;.query">#</a></h4>
<div class="doc">
<p>Returns the first node in the tree that matches the given 
<span class="param">queryOn</span>
parameter.</p>
<h2>Usage</h2><ul><li>query('tagName') // returns first occurance matching tag name.</li><li>
<p>query(XmlNodeType.CDATA) // returns first occurance of element matching
the given node type (CDATA node in this example).</p></li><li>
<p>query({'attributeName':'attributeValue'}) // returns the first occurance
of any <a class="crossref" href="../xml_utils_prujohn/XmlElement.html">XmlElement</a> where the given attributes/values are found.</p></li></ul>
<pre class="source">
XmlCollection&lt;E&gt; query(queryOn){
 XmlCollection&lt;E&gt; list = new XmlCollection._internal();

 if (queryOn is String){
   for (final node in this.allElements()){
     _queryNameInternal(queryOn, list, node);
     if (!list.isEmpty) break;
   }
 }else if (queryOn is XmlNodeType){
   for (final node in this){
     _queryNodeTypeInternal(queryOn, list, node);
     if (!list.isEmpty) break;
   }
 }else if (queryOn is Map){
   for (final node in this.allElements()){
     _queryAttributeInternal(queryOn, list, node);
     if (!list.isEmpty) break;
   }
 }

 return list;
}
</pre>
</div>
</div>
<div class="method"><h4 id="queryAll">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">XmlCollection</a>&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>queryAll</strong>(queryOn) <a class="anchor-link" href="#queryAll"
              title="Permalink to XmlCollection&lt;E&gt;.queryAll">#</a></h4>
<div class="doc">
<p>Returns a list of nodes in the tree that match the given 
<span class="param">queryOn</span>
parameter.</p>
<h2>Usage</h2><ul><li>query('tagName') = returns first occurance matching tag name.</li><li>
<p>query(XmlNodeType.CDATA) // returns first occurance of element matching
the given node type (CDATA node in this example).</p></li></ul>
<pre class="source">
XmlCollection&lt;E&gt; queryAll(queryOn){
 var list = new XmlCollection&lt;E&gt;._internal();

 if (queryOn is String){
   for (final node in this.allElements()){
     _queryAllNamesInternal(queryOn, list, node);
   }
 }else if (queryOn is XmlNodeType){
   for (final node in this){
     _queryAllNodeTypesInternal(queryOn, list, node);
   }
 }else if (queryOn is Map){
   for (final node in this.allElements()){
     _queryAllAttributesInternal(queryOn, list, node);
   }
 }

 return list;
}
</pre>
</div>
</div>
<div class="method"><h4 id="reduce">
<button class="show-code">Code</button>
dynamic <strong>reduce</strong>(combine(previousValue, <a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#reduce"
              title="Permalink to XmlCollection&lt;E&gt;.reduce">#</a></h4>
<div class="doc">
<p>Reduces a collection to a single value by iteratively combining elements
of the collection using the provided function.</p>
<p>Example of calculating the sum of an iterable:</p>
<pre><code>iterable.reduce((value, element) =&gt; value + element);
</code></pre>
<pre class="source">
dynamic reduce(dynamic combine(var previousValue, E element)) =&gt;
   _collection.reduce(combine);
</pre>
</div>
</div>
<div class="method"><h4 id="remove">
<button class="show-code">Code</button>
bool <strong>remove</strong>(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element) <a class="anchor-link" href="#remove"
              title="Permalink to XmlCollection&lt;E&gt;.remove">#</a></h4>
<div class="doc">
<p>Adds an element to this collection.</p>
<p>Adds all of <code>elements</code> to this collection.</p>
<p>Equivalent to adding each element in <code>elements</code> using <a class="crossref" href="../xml_utils_prujohn/XmlCollection.html#add">add</a>,
but some collections may be able to optimize it.</p>
<p>Removes an instance of 
<span class="param">element</span> from this collection.</p>
<p>This removes only one instance of the element for collections that can
contain the same element more than once (e.g., <a class="crossref" href="../dart_core/List.html">List</a>). Which instance
is removed is decided by the collection.</p>
<p>Has no effect if the elements is not in this collection.</p>
<pre class="source">
bool remove(E element) =&gt; _collection.remove(element);
</pre>
</div>
</div>
<div class="method"><h4 id="removeAll">
<button class="show-code">Code</button>
void <strong>removeAll</strong>(Iterable elements) <a class="anchor-link" href="#removeAll"
              title="Permalink to XmlCollection&lt;E&gt;.removeAll">#</a></h4>
<div class="doc">
<p>Removes all of 
<span class="param">elements</span> from this collection.</p>
<p>Equivalent to calling <a class="crossref" href="../xml_utils_prujohn/XmlCollection.html#remove">remove</a> once for each element in

<span class="param">elements</span>, but may be faster for some collections.</p>
<pre class="source">
void removeAll(Iterable elements) {
 for (var element in elements) {
   _collection.remove(element);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeAt">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">E</a> <strong>removeAt</strong>(int index) <a class="anchor-link" href="#removeAt"
              title="Permalink to XmlCollection&lt;E&gt;.removeAt">#</a></h4>
<div class="doc">
<p>Removes the element at position
<span class="param">index</span> from the list.</p>
<p>This reduces the length of the list by one and moves all later elements
down by one position.
Returns the removed element.
Throws an <a class="crossref" href="../dart_core/ArgumentError.html">ArgumentError</a> if 
<span class="param">index</span> is not an <a class="crossref" href="../dart_core/int.html">int</a>.
Throws an <a class="crossref" href="../dart_core/RangeError.html">RangeError</a> if the 
<span class="param">index</span> does not point inside
the list.
Throws an <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a>, and doesn't remove the element,
if the length of the list cannot be changed.</p>
<pre class="source">
E removeAt(int index) =&gt; _collection.removeAt(index);
</pre>
</div>
</div>
<div class="method"><h4 id="removeLast">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">E</a> <strong>removeLast</strong>() <a class="anchor-link" href="#removeLast"
              title="Permalink to XmlCollection&lt;E&gt;.removeLast">#</a></h4>
<div class="doc">
<p>Pops and returns the last element of the list.
Throws a <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a> if the length of the
list cannot be changed.</p>
<pre class="source">
E removeLast() =&gt; _collection.removeLast();
</pre>
</div>
</div>
<div class="method"><h4 id="removeRange">
<button class="show-code">Code</button>
void <strong>removeRange</strong>(int start, int length) <a class="anchor-link" href="#removeRange"
              title="Permalink to XmlCollection&lt;E&gt;.removeRange">#</a></h4>
<div class="doc">
<p>Removes 
<span class="param">length</span> elements from the list, beginning at 
<span class="param">start</span>.
Throws an <a class="crossref" href="../dart_core/UnsupportedError.html">UnsupportedError</a> if the list is
not extendable.
If 
<span class="param">length</span> is 0, this method does not do anything.
Throws an <a class="crossref" href="../dart_core/ArgumentError.html">ArgumentError</a> if 
<span class="param">length</span> is negative.
Throws an <a class="crossref" href="../dart_core/RangeError.html">RangeError</a> if 
<span class="param">start</span> or
<code>:start + length: - 1</code> are out of range.</p>
<pre class="source">
void removeRange(int start, int length) {
 _collection.removeRange(start, length);
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeWhere">
<button class="show-code">Code</button>
void <strong>removeWhere</strong>(bool test(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#removeWhere"
              title="Permalink to XmlCollection&lt;E&gt;.removeWhere">#</a></h4>
<div class="doc">
<p>Removes all elements of this collection that satisfy 
<span class="param">test</span>.</p>
<p>An elements <code>e</code> satisfies 
<span class="param">test</span> if <code>test(e)</code> is true.</p>
<pre class="source">
void removeWhere(bool test(E element)) =&gt; _collection.removeWhere(test);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="replaceRange">
<button class="show-code">Code</button>
void <strong>replaceRange</strong>(int start, int end, Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; newContents) <a class="anchor-link" href="#replaceRange"
              title="Permalink to XmlCollection&lt;E&gt;.replaceRange">#</a></h4>
<div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Removes the objects in the range 
<span class="param">start</span> inclusive to 
<span class="param">end</span> exclusive
and replaces them with the contents of the <code>iterable</code>.</p>
<pre><code>List&lt;int&gt; list = [1, 2, 3, 4];
list.replaceRange(1, 3, [6, 7]);
list.join(', '); // '1, 6, 7, 4'
</code></pre>
<p>An error occurs if 
<span class="param">start</span>..
<span class="param">end</span> is not a valid range for <code>this</code>.</p>
<div class="docs-inherited-from">docs inherited from List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
void replaceRange(int start, int end, Iterable&lt;E&gt; newContents) {
 _rangeCheck(start, end);
 if (newContents is! EfficientLength) {
   newContents = newContents.toList();
 }
 int removeLength = end - start;
 int insertLength = newContents.length;
 if (removeLength &gt;= insertLength) {
   int delta = removeLength - insertLength;
   int insertEnd = start + insertLength;
   int newLength = this.length - delta;
   this.setRange(start, insertEnd, newContents);
   if (delta != 0) {
     this.setRange(insertEnd, newLength, this, end);
     this.length = newLength;
   }
 } else {
   int delta = insertLength - removeLength;
   int newLength = this.length + delta;
   int insertEnd = start + insertLength;  // aka. end + delta.
   this.length = newLength;
   this.setRange(insertEnd, newLength, this, end);
   this.setRange(start, insertEnd, newContents);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="retainAll">
<button class="show-code">Code</button>
void <strong>retainAll</strong>(Iterable elements) <a class="anchor-link" href="#retainAll"
              title="Permalink to XmlCollection&lt;E&gt;.retainAll">#</a></h4>
<div class="doc">
<p>Removes all elements of this collection that are not
in 
<span class="param">elements</span>.</p>
<p>For <a class="crossref" href="../dart_core/Set.html">Set</a>s, this is the intersection of the two original sets.</p>
<pre class="source">
void retainAll(Iterable elements) {
 _collection.retainWhere((e) =&gt; elements.contains(e));
}
</pre>
</div>
</div>
<div class="method"><h4 id="retainWhere">
<button class="show-code">Code</button>
void <strong>retainWhere</strong>(bool test(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#retainWhere"
              title="Permalink to XmlCollection&lt;E&gt;.retainWhere">#</a></h4>
<div class="doc">
<p>Removes all elements of this collection that fail to satisfy 
<span class="param">test</span>.</p>
<p>An elements <code>e</code> satisfies 
<span class="param">test</span> if <code>test(e)</code> is true.</p>
<pre class="source">
void retainWhere(bool test(E element)) =&gt; _collection.retainWhere(test);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setAll">
<button class="show-code">Code</button>
void <strong>setAll</strong>(int index, Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; iterable) <a class="anchor-link" href="#setAll"
              title="Permalink to XmlCollection&lt;E&gt;.setAll">#</a></h4>
<div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Overwrites objects of <code>this</code> with the objects of 
<span class="param">iterable</span>, starting
at position 
<span class="param">index</span> in this list.</p>
<pre><code>List&lt;String&gt; list = ['a', 'b', 'c'];
list.setAll(1, ['bee', 'sea']);
list.join(', '); // 'a, bee, sea'
</code></pre>
<p>This operation does not increase the length of <code>this</code>.</p>
<p>An error occurs if the 
<span class="param">index</span> is less than 0 or greater than length.
An error occurs if the 
<span class="param">iterable</span> is longer than <a class="crossref" href="../xml_utils_prujohn/XmlCollection.html#length">length</a> - 
<span class="param">index</span>.</p>
<div class="docs-inherited-from">docs inherited from List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
void setAll(int index, Iterable&lt;E&gt; iterable) {
 if (iterable is List) {
   setRange(index, index + iterable.length, iterable);
 } else {
   for (E element in iterable) {
     this[index++] = element;
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setRange">
<button class="show-code">Code</button>
void <strong>setRange</strong>(int start, int length, List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; from, [int startFrom]) <a class="anchor-link" href="#setRange"
              title="Permalink to XmlCollection&lt;E&gt;.setRange">#</a></h4>
<div class="doc">
<p>Copies 
<span class="param">length</span> elements of 
<span class="param">from</span>, starting
at 
<span class="param">startFrom</span>, into the list, starting at 
<span class="param">start</span>.
If 
<span class="param">length</span> is 0, this method does not do anything.
Throws an <a class="crossref" href="../dart_core/ArgumentError.html">ArgumentError</a> if 
<span class="param">length</span> is negative.
Throws an <a class="crossref" href="../dart_core/RangeError.html">RangeError</a> if 
<span class="param">start</span> or
<code>start + length - 1</code> are out of range for <code>this</code>, or if

<span class="param">startFrom</span> or <code>startFrom + length - 1</code> are out of range for 
<span class="param">from</span>.</p>
<pre class="source">
void setRange(int start, int length, List&lt;E&gt; from, [int startFrom]) {
 _collection.setRange(start, length, from, startFrom);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="shuffle">
<button class="show-code">Code</button>
void <strong>shuffle</strong>([Random random]) <a class="anchor-link" href="#shuffle"
              title="Permalink to XmlCollection&lt;E&gt;.shuffle">#</a></h4>
<div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Shuffles the elements of this list randomly.</p>
<div class="docs-inherited-from">docs inherited from List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
void shuffle([Random random]) {
 if (random == null) random = new Random();
 int length = this.length;
 while (length &gt; 1) {
   int pos = random.nextInt(length);
   length -= 1;
   var tmp = this[length];
   this[length] = this[pos];
   this[pos] = tmp;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="singleWhere">
<button class="show-code">Code</button>
<a href="../xml_utils_prujohn/XmlCollection.html">E</a> <strong>singleWhere</strong>(bool test(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> value)) <a class="anchor-link" href="#singleWhere"
              title="Permalink to XmlCollection&lt;E&gt;.singleWhere">#</a></h4>
<div class="doc">
<p>Returns the single element that satisfies <code>f</code>. If no or more than one
element match then a <a class="crossref" href="../dart_core/StateError.html">StateError</a> is thrown.</p>
<pre class="source">
E singleWhere(bool test(E value)) =&gt; _collection.singleWhere(test);
</pre>
</div>
</div>
<div class="method"><h4 id="skip">
<button class="show-code">Code</button>
Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>skip</strong>(int n) <a class="anchor-link" href="#skip"
              title="Permalink to XmlCollection&lt;E&gt;.skip">#</a></h4>
<div class="doc">
<p>Returns an <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> that skips the first 
<span class="param">n</span> elements.</p>
<p>If <code>this</code> has fewer than 
<span class="param">n</span> elements, then the resulting <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> will
be empty.</p>
<pre class="source">
Iterable&lt;E&gt; skip(int n) =&gt; _collection.skip(n);
</pre>
</div>
</div>
<div class="method"><h4 id="skipWhile">
<button class="show-code">Code</button>
Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>skipWhile</strong>(bool test(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> value)) <a class="anchor-link" href="#skipWhile"
              title="Permalink to XmlCollection&lt;E&gt;.skipWhile">#</a></h4>
<div class="doc">
<p>Returns an <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> that skips elements while 
<span class="param">test</span> is satisfied.</p>
<p>The filtering happens lazily. Every new <a class="crossref" href="../dart_core/Iterator.html">Iterator</a> of the returned
<a class="crossref" href="../dart_core/Iterable.html">Iterable</a> will iterate over all elements of <code>this</code>.
As long as the iterator's elements do not satisfy 
<span class="param">test</span> they are
discarded. Once an element satisfies the 
<span class="param">test</span> the iterator stops testing
and uses every element unconditionally.</p>
<pre class="source">
Iterable&lt;E&gt; skipWhile(bool test(E value)) =&gt; _collection.skipWhile(test);
</pre>
</div>
</div>
<div class="method"><h4 id="sort">
<button class="show-code">Code</button>
void <strong>sort</strong>([int compare(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> a, <a href="../xml_utils_prujohn/XmlCollection.html">E</a> b)]) <a class="anchor-link" href="#sort"
              title="Permalink to XmlCollection&lt;E&gt;.sort">#</a></h4>
<div class="doc">
<p>Sorts the list according to the order specified by the 
<span class="param">compare</span> function.</p>
<p>The 
<span class="param">compare</span> function must act as a <a class="crossref" href="../dart_core/Comparator.html">Comparator</a>.
The default <a class="crossref" href="../dart_core/List.html">List</a> implementations use <a class="crossref" href="../dart_core/Comparable.html#compare">Comparable.compare</a> if

<span class="param">compare</span> is omitted.</p>
<pre class="source">
void sort([int compare(E a, E b)]) {
 _collection.sort(compare);
}
</pre>
</div>
</div>
<div class="method"><h4 id="sublist">
<button class="show-code">Code</button>
List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>sublist</strong>(int start, [int end]) <a class="anchor-link" href="#sublist"
              title="Permalink to XmlCollection&lt;E&gt;.sublist">#</a></h4>
<div class="doc">
<p>Returns a new list containing the elemenst from 
<span class="param">start</span> to 
<span class="param">end</span>.</p>
<p>If 
<span class="param">end</span> is omitted, the <a class="crossref" href="../xml_utils_prujohn/XmlCollection.html#length">length</a> of the list is used.</p>
<p>It is an error if 
<span class="param">start</span> or 
<span class="param">end</span> are not list indices for this list,
or if 
<span class="param">end</span> is before 
<span class="param">start</span>.</p>
<pre class="source">
List&lt;E&gt; sublist(int start, [int end]) =&gt; _collection.sublist(start, end);
</pre>
</div>
</div>
<div class="method"><h4 id="take">
<button class="show-code">Code</button>
Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>take</strong>(int n) <a class="anchor-link" href="#take"
              title="Permalink to XmlCollection&lt;E&gt;.take">#</a></h4>
<div class="doc">
<p>Returns an <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> with at most 
<span class="param">n</span> elements.</p>
<p>The returned <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> may contain fewer than 
<span class="param">n</span> elements, if <code>this</code>
contains fewer than 
<span class="param">n</span> elements.</p>
<pre class="source">
Iterable&lt;E&gt; take(int n) =&gt; _collection.take(n);
</pre>
</div>
</div>
<div class="method"><h4 id="takeWhile">
<button class="show-code">Code</button>
Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>takeWhile</strong>(bool test(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> value)) <a class="anchor-link" href="#takeWhile"
              title="Permalink to XmlCollection&lt;E&gt;.takeWhile">#</a></h4>
<div class="doc">
<p>Returns an <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> that stops once 
<span class="param">test</span> is not satisfied anymore.</p>
<p>The filtering happens lazily. Every new <a class="crossref" href="../dart_core/Iterator.html">Iterator</a> of the returned
<a class="crossref" href="../dart_core/Iterable.html">Iterable</a> will start iterating over the elements of <code>this</code>.
When the iterator encounters an element <code>e</code> that does not satisfy 
<span class="param">test</span>,
it discards <code>e</code> and moves into the finished state. That is, it will not
ask or provide any more elements.</p>
<pre class="source">
Iterable&lt;E&gt; takeWhile(bool test(E value)) =&gt; _collection.takeWhile(test);
</pre>
</div>
</div>
<div class="method"><h4 id="toList">
<button class="show-code">Code</button>
List&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>toList</strong>({growable: true}) <a class="anchor-link" href="#toList"
              title="Permalink to XmlCollection&lt;E&gt;.toList">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a <a class="crossref" href="../dart_core/List.html">List</a> containing the elements of this <a class="crossref" href="../dart_core/Iterable.html">Iterable</a>.</p>
<p>The elements are in iteration order. The list is fixed-length
if 
<span class="param">growable</span> is false.</p>
<div class="docs-inherited-from">docs inherited from Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
List&lt;E&gt; toList({growable : true}) =&gt; new List&lt;E&gt;.from(this);
</pre>
</div>
</div>
<div class="method"><h4 id="toSet">
<button class="show-code">Code</button>
Set&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>toSet</strong>() <a class="anchor-link" href="#toSet"
              title="Permalink to XmlCollection&lt;E&gt;.toSet">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a <a class="crossref" href="../dart_core/Set.html">Set</a> containing the elements of this <a class="crossref" href="../dart_core/Iterable.html">Iterable</a>.</p>
<div class="docs-inherited-from">docs inherited from Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div></div>
<pre class="source">
Set&lt;E&gt; toSet() =&gt; new Set&lt;E&gt;.from(this);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to XmlCollection&lt;E&gt;.toString">#</a></h4>
<div class="inherited-from">mixed in from ListMixin&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; </div><div class="doc">
<div class="inherited">
<p>Returns a string representation of this object.</p>
<div class="docs-inherited-from">docs inherited from Object </div></div>
<pre class="source">
String toString() {
 if (_toStringVisiting.contains(this)) {
   return '[...]';
 }

 var result = new StringBuffer();
 try {
   _toStringVisiting.add(this);
   result.write('[');
   result.writeAll(this, ', ');
   result.write(']');
  } finally {
    _toStringVisiting.remove(this);
  }

 return result.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="where">
<button class="show-code">Code</button>
Iterable&lt;<a href="../xml_utils_prujohn/XmlCollection.html">E</a>&gt; <strong>where</strong>(bool f(<a href="../xml_utils_prujohn/XmlCollection.html">E</a> element)) <a class="anchor-link" href="#where"
              title="Permalink to XmlCollection&lt;E&gt;.where">#</a></h4>
<div class="doc">
<p>Returns a lazy <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> with all elements that satisfy the
predicate 
<span class="param">f</span>.</p>
<p>This method returns a view of the mapped elements. As long as the
returned <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> is not iterated over, the supplied function 
<span class="param">f</span> will
not be invoked. Iterating will not cache results, and thus iterating
multiple times over the the returned <a class="crossref" href="../dart_core/Iterable.html">Iterable</a> will invoke the supplied
function 
<span class="param">f</span> multiple times on the same element.</p>
<pre class="source">
Iterable&lt;E&gt; where(bool f(E element)) =&gt; _collection.where(f);
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-12-31 15:01:30.754</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
